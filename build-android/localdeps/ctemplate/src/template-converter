#!/usr/bin/perl -w
#
# Copyright 2001 Google Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#     * Neither the name of Google Inc. nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# ---
# Author: Andrew Fikes
#
# Tool to convert a template file (.tpl) into a C++ header
# file with a const string defining the same template.  This string
# can then be used to create/retrieve a template using
# Template::StringToTemplate()/StringToTemplateCache() (see template.h).
#
# Usage: template-converter <template_name> < infile > outfile
#
# template_name is the name of the variable we export.  A good choice
# is to pass in the outfile name.  To make that easier, we treat
# <template_name> as a pathname, and take the basename, strip the
# suffix if it's .h, and sanitize the rest of the name to be a legal
# C variable name.
# MOE:insert # NOTE: See doc/index.html for a general description of Google ctemplate.


# Store the input argv.
my $argv = join(" ", $0, @ARGV);

# Open template file
(my $template_name = shift) || usage("Need to specify template variable name.");

# If a second argument is supplied, treat it as an input filename.
if (my $infile = shift) {
  open(STDIN, "<", $infile) or usage("Can't open $infile for reading.");
}

# If a third argument is supplied, treat it as an output filename.
if (my $outfile = shift) {
  open(STDOUT, ">", $outfile) or usage("Can't open $outfile for writing.");
}

# Get base name of template file
$base_name = $template_name;
$base_name =~ s|^.*/([^/]*)$|$1|;  # Strip out directory name
$base_name =~ s|\.h$||;            # Strip out suffix, if it's .h
$base_name =~ tr|A-Za-z0-9_|_|c;   # Sanitize name to remove non-letters/nums

# Print header
print "// This file automatically generated by template-converter:\n";
print "//    $argv\n";
print "//\n";
print "// DO NOT EDIT!\n\n";
print "#ifndef " . uc($base_name) . "_H_\n";
print "#define " . uc($base_name) . "_H_\n\n";
print "#include <string>\n\n";

# Read in template file and print template as a string
# MOE:begin_strip
print "const string ${base_name} (\n";
# MOE:end_strip_and_replace print "const std::string ${base_name} (\n";
while (<>) {
  chomp;
  my $escaped_line = escape_line($_);
  print "\"$escaped_line\\n\"\n";
}
print ");\n\n";

# Print footer and exit
print "#endif /* " . uc($base_name) . "_H_ */\n";
exit(0);

# Prints usage message
sub usage {
  my $msg = shift;
  print STDERR "\n$msg\n";
  print STDERR "Usage: template-converter <template-varname>",
               " [infile] [outfile]\n\n";
  exit(1);
}

# Escapes line (adds a '\' to quotes and possible control characters)
sub escape_line {
  (my $line) = (@_);
  $line =~ s|\\|\\\\|g;
  $line =~ s|\"|\\"|g;
  return $line;
}
